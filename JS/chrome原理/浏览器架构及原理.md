# 浏览器原理
## chrome架构

### 进程和线程

- 进程：资源分配的最小单位，线程： 程序执行的最小单位（资源调度最小单位）
- 进程有自己独立的地址空间，每启动一个进程，系统会为其分配地址空间，建立数据表来维护代码段，堆栈段和数据段。操作非常昂贵。
- 线程共享进程中数据，使用相同地址空间，CPU创建和切换线程开销较小。
- 线程之间通信方便，进程间需要（IPC）方式通信，如何编写好同步与互斥是多线程程序难点。
- 多进程程序更健壮，独立地址空间，多线程只要一个线程死掉，整个进程也会死掉

### 浏览器时代
- 单进程： 不稳定，不流畅，不安全

### 多进程浏览器
- 浏览器进程：负责用户交互，子进程管理和文件储存功能。
- 渲染进程： 从网络下载的html，JS，CSS，图片等资源解析为可以显示和交互的页面（沙箱）
- 网络进程： 面向渲染进程和浏览器进程等提供网络下载功能
- GPU进程
- 插件进程

### 未来架构
- 面向服务（SOA）

## 前端网络
重要性：性能

### TCP/IP
- 计算机地址，网络空间唯一标识一台主机
- IP： 数据包送达目的主机
- UDP：数据包送达应用程序，不保证可靠性，传输速度快
- TCP：把数据完整送达应用程序，面向连接，可靠，基于字节流的传输层通信协议

### 三次握手与四次挥手

### http请求流程
HTTP协议： 建立在TCP连接基础上，一种允许浏览器向服务器获取资源的协议，是web的基础
1. 构建请求（GET /index.html HTTP1.1）
2. 查找缓存： 强缓存和协商缓存（304）
3. 准备IP地址和端口：DNS
4. 等待TCP队列： 同一个域名同时最多只能建立6个TCP连接
5. 建立TCP连接
6. 发送HTTP请求：请求行，请求头，请求体
7. 服务端处理HTTP请求，返回： 响应行（状态码），响应头，响应体
8. 断开连接（keep-alive）

## HTTP简史及未来
### HTTP/0.9
- 只有一个请求行，无HTTP请求头和请求体
- 服务器没有返回头信息，服务端并不需要告诉客户端太多信息，只要返回数据就行
- 因为都是html文件，内容以ASCII 字符流传输
### 浏览器推动的HTTP/1.0
- 请求头和响应头： 支持文件类型，压缩，编码类型，语言版本
- 引入状态码
- 提供cache机制（缓存）
- 加入了用户代理字段
### 1.1
- 增加了持久连接：一个TCP连接上可以传输多个HTTP请求
- 不成熟的HTTP管线化： TCP队头阻塞
- 提供虚拟主机支持： 增加HOst字段表示当前域名地址
- 动态生成内容提供了完美支持： Chunk transfer机制（Bigpipe）
- Cookie，安全机制
#### 1.1 为网络效率做了大量优化：核心的三种方式：
1. 增加持久连接
2. 每个域名最多同时维护6个TCP持久连接
3. 使用CDN实现域名分片机制

#### 1.1主要问题
- 对带宽利用率不理想
- TCP慢启动
- 同时开启多条TCP连接，竞争固定带宽资源
- 队头阻塞

### HTTP/2.0
- 一个域名只使用一个TCP长连接，消除队头阻塞问题
- 多路复用机制

- 设置请求优先级
- 服务器推送
- 头部压缩

应用层完美协议，但传输控制层还是TCP，还是有队头阻塞问题
### HTTP/3.0
- 解决了2.0中队头阻塞问题
- TCP建立连接的延时，需要花掉3-4个RTT(Round Trip Time)
- TCP协议僵化
- 基于UDP的QUIC
- 实现了类似TCP的流量控制，传输可靠性功能
- 集成了TLS加密功能（建立连接采用非对称加密，传输过程采用对称加密）
- 实现了快速握手功能
- 实现了2中的多路复用

### HTTPS

## 流程
输入URL到显示页面，经历了什么？

### 导航
- 浏览器进程接收url请求，将其转发给网络进程
- 网络进程中发起真正url请求。接收响应头数据，解析数据并转发给浏览器进程
- 浏览器进程接收到数据，发送“提交导航”（CommitNavigation）消息到渲染进程
- 渲染进程接收到“提交导航”消息，开始准备接收HTML数据，接收数据方式是直接和网络进程建立数据管道。
- 渲染进程向浏览器进程发送“确认提交”，告诉浏览器进程：“已准备好接收和解析页面数据”。浏览器进程收到渲染进程“提交文档”消息后，便开始移除就得文档，更新浏览器进程中页面状态。
### 渲染
#### 构建DOM树
浏览器无法直接理解和使用HTML（文档），会将HTML转换为浏览器能理解的结构---DOM树（浏览器内存结构）
#### 样式计算（继承，层叠）

- 渲染引擎接收到CSS文本，会执行一个转换操作，将CSS文本转换为浏览器能理解的结构--stylesheets（document.styleSheets）
- 转换样式表中的属性值，使其标准化
- 计算出DOM树种每个节点具体样式
#### 布局阶段
我们有DOM树和DOM树中的样式，因为我们还不知道DOM元素的几何位置信息，接下来要计算出DOM树中可见元素的几何位置
#### 分层， 绘制
- 渲染引擎需要为特定的节点生成专用的图层，并生成对应的图层树（LayerTree）
- 不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。
-  绘制列表 -》 执行绘制操作
#### 分块，光栅化（ 图块-> 位图 ）

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的，合成线程会将图层划分为图块（title），合成线程会按照视口附近的图块来优先
生成位图，实际生成位图的操作由栅格化来执行，栅格化就是指将图块转化为位图
#### 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令--“DrawQuad”，然后将该命令提交给浏览器进程，浏览器进程里有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后经内存显示在屏幕上

#### 总结
1. 渲染引擎将HTML内容转化为能够读懂的DOM树结构
2. 渲染引擎将CSS样式表转换为浏览器可以理解的styleSheets，计算出DOM节点的样式
3. 创建布局树，并计算元素布局信息
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，将其提交到合成线程
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图
7. 合成线程发送绘制图块命令DrawQuad 给浏览器进程
8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器

# JS执行机制
## JavaScript执行机制
### 变量提升
```JavaScript

showName()
console.log(myname)

var myname = '李刘超'

function showName() {
  console.log('函数执行')
}
```
变量提升： 指在JavaScript代码执行过程中，JS引擎把变量声明部分和函数的声明部分题到代码开头的“行为”。变量被提升后，会给变量设置默认值（undefined）。
实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被jS引擎放入内存中

#### 代码中出现相同变量或函数
```javascript
alert(a)
a();
var a = 3;
function a () {
  alert(10);
}
function a () {
  alert(a)
}

a = 6;
a()

结果： 20， 6， 报错
优先级：1. 声明式函数 》 变量 》  2. 后声明》 先声明
```
### 调用栈
哪些情况代码才算的“一段”代码，才会在执行之前就进行编译并创建上下文
1. 当JS执行全局代码的时候，会编译全局代码并创建全局执行上下文，而在整个页面生存周期内，全局执行上下文只有一份。
2. 调用一个函数的时候，函数体内的代码被编译，并创建执行函数上下文，一般情况，函数执行结束，创建的函数执行上下文会被销毁。
3. 使用eval函数的时候，eval的代码也会被编译，并创建执行上下文

### 块级作用域
由于JS存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是JS的一个重要设计缺陷，ES6已通过引入块级作用域并配合let 从const 来避开这种缺陷，但由于JS需要保持向下兼容，所以变量提升在相当长一段时间还会继续存在

#### 作用域
作用域指程序中定义变量的区域，该位置决定了变量的生命周期，通俗理解就是，变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期

变量提升带来的问题：
1. 变量容易在不被察觉额情况下被覆盖
2. 本应该销毁的变量没有被销毁

引入词法环境（let， const 声明的变量会放到词法环境中）： 变量在声明时已经指定了他的存储结构

JS如何支持块级作用域
```javascript
let a = 2 
console.log(a)
{
  console.log(a)
  function a () { console.log(1) }
}
console.log（a）
```
### 作用域链和闭包
词法作用域是代码阶段就决定好的，和函数怎么调用没有关系。

在每个执行上下文变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，这个外部引用称为outer。当一段代码使用了一个变量时，如果在当前的变量环境中没有查到，那么JS引擎会继续在outer所指向的执行上下文中查找
### 闭包

原理：
执行上下文: 变量环境， 词法环境，outer（通过outer 连接作用域），this

```javascript
function foo () {
  var myName = 'li'
  let test1 = 1
  const test2 = 2

  var innerBar = {
    getName: function () {
      console.log(test1)
      return myName
    },
    setName: function (newName) {
      myName = newName
    }
  }
  return innerBar
}

var bar = foo()
bar.setName('liu')
bar.getName()
console.log(bar.getName())
```
根据词法作用域规则，内部函数getName和setName总是可以访问到外部函数foo中的变量，所以当innerBar对象返回给全局变量bar时，虽然foo函数已经执行结束，但是getName和setName函数依然可以使用foo中的函数变量myName和test1

<b>闭包: </b>JS中，根据词法规则，内部函数总是可以访问其外部函数中声明的变量，当通过一个调用外部函数返回一个内部函数后，即使该外部函数已经执行结束，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包，比如外部函数是foo，那么这些变量的集合就称为foo函数的闭包。

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。尽量让它称为一个局部变量

### this
全局执行上下文中this指向window对象
函数执行上下文中this：
- 通过call方法设置
- 通过对象调用方法设置
- 通过构造函数设置new

#### this设计缺陷及应对方案
- 嵌套函数中的this 不会存根外层函数继承
```javascript
var myObj = {
  name: 'li',
  showThis: function() {
    console.log(this)
    function bar() {
      console.log(this)
    }
    bar()
  }

}
```
函数bar 中的this指向的是window。而函数showThis中的this指向myObj
- 普通函数中this默认指向全局对象window

在严格模式下，默认执行一个函数，其函数执行上下文中this值为undfined

解决： 1. 箭头函数， 2. var self = this， 3. bind 4. 立即执行函数

### 栈空间和堆空间
JS： 弱类型，动态语言

原始数据类型存储在栈空间中，引用类型数据存储在堆空间中，在栈空间保存着对其的引用
### 垃圾回收
JS引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。要回收堆中的数据，就需要用到JS中的垃圾回收器了。

代际假说和分代收集：

代际假说有一下两个特点：1. 大部分对象在内存中存在时间很短，简单来说就是，很多对象一经分配内存，很快就变得不可访问；第二个是不死的对象，会活的更久。

V8中会把堆分为新生代和老生代两个区，新生代中存放的是生存时间短的对象，老生代中存放的生存时间长久的对象。

副垃圾回收器，主要负责新生代垃圾回收，主垃圾回收器，主要负责老生代的垃圾回收。

垃圾回收器工作流程：
- 第一步是标记空间中活动对象和非活动对象。活动对象指还在使用的对象，非活动对象是可以进行垃圾回收的对象
- 第二步是回收非活动对象所占的内存，其实就是在所有标记完成后，统一清理内存中所有被标记为可回收的对象
- 第三步是做内存整理，一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这一部是可选的，因为有的垃圾回收器不会产生内存碎片。

#### 副垃圾回收器：

Scavenge算法：

V8堆空间：新生区分对象区域和空闲区域

角色翻转的操作还可以让新生代中的这两块区域无限重复使用下去，经过两次垃圾回收依然还存活的对象，会被移动到老生区中

#### 主垃圾回收器
采用标记-清除（Mark-Sweep）算法
一旦执行垃圾回收算法，都需要将正在执行的JS脚本暂停下来，待垃圾回收完毕再恢复脚本执行。这种行为叫做全停顿（Stop-The-World）

增量标记（Incremental Marking）算法

### 编译器和解释器
编译型语言在程序执行之前，需要经过编译器编译的过程，并且编译后会直接保留机器能读懂的二进制文件，每次运行程序时，都可以直接运行该二进制文件，而不需重新编译。C/C++，GO等。
由解释型语言编写的程序，每次运行时都需要通过解释器对程序进行动态解释和执行。比如Python，JS等

编译： 源码-（词法，语法分析）-》AST -（语义分析）-》中间代码-（代码优化）-》（二进制文件）-（直接执行）-》 执行

解释 ：源码-（词法，语法分析）-》AST -（语义分析）-》 字节码-（解释执行）-》 执行

### V8是如何执行一段JS代码的
- 将源代码转换为AST，并生成执行上下文：

AST：非常重要的一种数据结构，很多项目中有着广泛的应用。最著名的就是Babel。Babel是一个被广泛应用的代码转换器，可以将ES6转换为ES5代码。Babel的工作原理就是，先将ES6源码转换为AST，然后在将ES6语法的AST转换为ES5的AST，最后利用ES5的AST生成JS源代码。

  1. 第一阶段是分词（tokenize）,又叫词法分析
  2. 第二阶段是解析（parse）, 又叫语法分析
- 生成字节码：
解释器Ignition登场，它会根据AST生成字节码，并解释执行字节码。
字节码是介于AST和机器码之间的一种代码，但与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行
- 执行代码：
生字节码后，接下来进入执行阶段，通常，如果有一段第一次执行的字节码，解释器Ignition会逐条解释执行。你会发现，解释器Ignition除了负责生成字节码，还有另一个作用就是解释执行字节码，在Ignition执行字节码过程中，如果发现有热点代码（HotSpot），比如一段代码重复执行多次，那么后台编译器TurboFan就会把该段热点字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，大大提高执行效率。

字节码配合解释器和编译器是最近一段时间很火的技术<b>即时编译（JIT）</b>

### 消息队列和事件循环
要想在线程运行过程中，能接收并执行新的任务，就要采用时间循环机制。

（图片）

消息队列是一种数据结构，可以存放要执行的任务。符合队列先进先出特点，添加任务到队尾，执行任务从队头取出。

消息队列： 输入事件（鼠标移动，滚动，点击），微任务，，文件读写，WebSocket，JS定时器等等，除此之外，消息队列中还包含了很多与页面相关的事件，如JS执行，解析DOM，样式计算，布局计算，CSS动画等。

#### 页面使用单线程缺点
页面线程所有执行的任务都来自消息队列，先进先出属性，就是说，放入队列中的任务，需要等前面的任务执行完，才会执行
#### 如何处理高优先级任务
如果DOM发生变化，采用同步通知方式，会影响当前任务执行效率：如果采用异步方式，又会影响监控的实时性。

通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，执行宏任务的过程中，如果DOM有变化，就会将该变化添加到微任务列表中，就不会影响到宏任务的继续执行，
#### 单个任务执行时间过久的问题
如果在执行动画过程中，其中有个JS任务执行时间过久，占用了动画帧的时间，就会给用户造成卡顿的感觉，针对这种情况，JS可以通过回调功能来规避这种问题，也就是让要执行的JS任务滞后执行。
#### 宏任务（一般由浏览器维护）
- 渲染事件（DOM解析，计算布局，绘制）
- 用户交互事件（鼠标点击，页面滚动，放大缩小等）
- JS脚本执行事件
- 网络请求完成，文件读写完成事件
#### 微任务（一般由V8引擎维护）
微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束，当前宏任务结束之前。当JS执行一段脚本时，V8会为其创建一个全局执行上下文，在创建全局执行上下文同时，V8引擎也会在内部创建一个微任务队列。
MutationObserver， Promise

图片（Promise，异步编程模型）

Promise：消灭嵌套调用和多次错误处理：
1. 为什么要引入微任务？：
由于Promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需要等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前JS调用栈中执行结束后的任务中，由于宏任务较多容易堵塞，所以引入了微任务。
2. Promise是如何实现回调函数返回值穿透的？：首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即成功返回new Promise（resolved），将前一个promise的data值赋给新建的promise。
3. Promise 出错后，怎么通过“冒泡”传递给最后那个捕获？：
Promise 内部有resolved和rejected变量，保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，如果是，错误时使用rejected处理错误，如不是，则错误时直接throw错误，一直传递到最后的捕获，如最后没有捕获，则会报错。可以通过监听unhandledrejection事件捕获未处理的promise错误

### async/await:


## DOM树
从网络传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构（DOM）
- 从页面角度： DOM是生成页面的基础数据结构
- 从JS脚本角度：DOM提供给JS脚本操作的接口，通过这套接口，JS可以对DOM结构进行访问，从而改变文档结构，样式和内容
- 从安全角度：DOM是一道安全防护线，一些不安全的内容在DOM解析阶段就被拒之门外了。

### DOM树如何生成
HTML解析器

网络进程加载了多少数据，HTML解析器就解析多少数据
网络进程接收到响应头之后，会根据响应头中的content-type字段来判断文件类型，比如content-type为“text/html”,那么浏览器就会判断这是HTML文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里放，而渲染进程则从另一端不断读取数据，并同时将读取的数据“喂”给HTML解析器。

1. 通过分词器将字节流转换为Token
2. 将Token解析为DOM节点，并将DOM节点添加到DOM树（这两个阶段是同时进行的）

HTML解析器维护了一个Token栈结构，该Token栈主要用来计算节点之间的父子关系，在第一阶段中生成的Token会被按照顺序压到这个栈中。
- 如果压入到栈中的是StartTag Token，HTML解析器会为该Token创建一个DOM节点，然后将该节点加入到DOM树中，它的父节点就是栈中相邻的那个元素生成的节点。
- 如果分词器解析出来是文本Token，那么会生成一个文本节点，然后将该节点加入DOM树，文本Token是不需要压入栈中，它的父节点就是当前栈顶Token所对应的DOM节点。
- 如果分词器解析出来是EndTag标签，比如EndTag div，HTML解析器会查看Token栈顶的元素是否是StartTag，是，就将StartTag div从栈中弹出，表示该div元素解析完成。

实际生产环境中，HTML源文件包含CSS和JS，又包含图片，音频，视频等文件。处理过程远比上述过程复杂。
### JavaScript是如何影响DOM生成的
- 当解析到内嵌JS脚本标签时，HTML解析器暂停工作，JS引擎介入，并执行script标签中的脚本，脚本会修改DOM中的内容，脚本执行完毕，HTML解析器恢复解析过程，继续解析后续内容，直至生成最终DOM
- JS文件下载过程会阻塞DOM解析
- Chrome浏览器做了很多优化，其中一个主要优化是与解析操作。渲染引擎收到字节流之后，会开启一个预解析线程，用来分析HTML文件中包含的JS，CSS等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件
- 使用CDN加速JS文件加载，压缩JS文件体积。
- 可以将JS脚本设置为异步加载，通过async或defer标记

在执行JS代码前，需要先解析JS语句之上所有CSS样式，所以如果代码里引用了外部CSS文件，那么在执行JS之前，还需要等外部的CSS文件下载完毕，并解析生成CSSOM对象之后，才能执行JS脚本。

不管该脚本是否操纵了CSSOM，都会执行CSS文件下载，解析操作，在执行JS脚本。

总结：JS会阻塞DOM生成，而样式文件又会阻塞JS执行

## CSS如何影响首次加载
（图片：网络进程与渲染进程）
### 渲染流水线为什么需要CSSOM：
- 提供给JS操作样式表的能力
- 布局树的合成提供基础样式信息

CSSOM体现在DOM中就是document.styleSheets。 等DOM和CSSOM都构建好之后，渲染引擎就会构造布局树。

### 缩短白屏时长策略
- 通过内联CSS，JavaScript来移除这两种类型的文件下载，这样获取到HTML文件之后就可以直接开始渲染流程了
- 但并不是所有场合都适合内联，还可以尽量减少文件大小，比如通过webpack等工具移除一些不必要的注释，压缩JS文件等
- 可以将不需要解析HTML阶段使用的JS标签标记上async 或者 defer
- 对于大的CSS文件，可以通过媒体查询属性，将其拆分为多个不同用途的CSS文件，这样只有在特定的场景下才会加载特定的CSS文件。

## CSS动画比jS高效
### 显示器是怎样画图像的
每个显示器都有固定的刷新频率，通常是60HZ，也就是每秒更新60张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取60次前缓冲区的图像，显示到显示器上。

显卡的更新频率和显示器的刷新频率是一致的，显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统会让后缓冲区和前缓冲区互换，这样就能保证显示器能读到最新显卡合成的图像

#### 任意一帧的生成方式，有重排，重绘和合成三种方式

这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，需要重新根据CSSOM和DOM计算布局树，这样在生成一副图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染效率了。而重绘因为没有了重新布局阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

相较于重排和重绘，合成操作的路径就非常短了，并不需要触发布局和绘制两个阶段，如果采用了GPU，那么合成的小率就会非常高。

合成操作是在合成线程上完成的，也就意味着在执行合成操作时，是不会影响到主线程执行的。

### 如何利用分层技术优化代码
- 写web应用的时候，你可能经常需要对某个元素做几何形状变幻，透明度变幻或者一些缩放操作，如果使用JS来写这些效果，会牵涉到整个渲染流水线，所以JS绘制效率会非常低下。
- 可以使用will-change 来告诉渲染引擎你会对该元素做一些特效变换，提前告诉渲染引擎box元素将要做几何变换和透明度变幻操作，这时候渲染引擎会将该元素单独实现一帧，等这些变幻发生时，渲染引擎会通过合成线程直接去处理变幻，这些变幻并没有涉及到主线程，这样就大大提升了渲染的效率。这也是CSS动画比JS动画高效的原因。

## 优化页面
让页面更快的显示和响应
### 加载阶段
- 减少关键资源个数，一种方式是可以将JavaScript和CSS改成内联式。减少关键资源的个数。另一种方式，如果JS代码没有DOM或者CSSOM操作，则可以改成async 或者defer属性；同样对于CSS，如果不是在页面加载之前加载的，则可以添加媒体取消阻止显现的标志。当Javascript标签加上async或者defer，CSSlink属性之前加上取消阻止显现的标志后，他们就变成了非关键资源了。
- 降低关键资源大小： 压缩CSS和JS资源，移除HTML，CSS，JavaScript文件中一些注释内容，也可以通过前面的取消CSS或者JavaScript中关键资源的方式
- 降低关键资源RTT次数（Round Trip Time）： 通过减少关键资源个数和减少关键资源大小搭配来实现，还可以使用CDN减少每次RTT时长
### 交互阶段：
- 减少JavaScript脚本执行时间，将一次执行的函数分解为多个任务，使得每次执行时间不要过久，采用Web Workers
- 避免强制同步布局，尽量不要在修改DOM结构时再去查询一些相关值
- 合理利用CSS合成动画
- 避免频繁垃圾回收

## 浏览器安全
### 同源策略
两个URL的协议，域名，端口都相同，认为这两个URL同源
同源策略会隔离不同源的DOM，页面通信和网络通信，进而实现web页面安全性。不过要绝对的安全就要牺牲掉便利性，因此我们要在二者之间做权衡，找到中间的一个平衡点，也就是目前的页面安全策略原型
- 页面中可以引入第三方资源，不过这也暴露了很多诸如XSS的安全问题，因此又在这种开发的基础上引入了CSP来限制其自由程度
- 使用XMLHttpRequest和Fetch都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础上引入了跨域资源共享策略，让其可以安全的进行跨域操作。
- 两个不同源的DOM是不能相互操作的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全的通信。

## 跨站脚本攻击（XSS）
XSS攻击是指黑客往HTML文件中或者DOM中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
- 窃取Cookie信息
- 监听用户行为
- 修改DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息
- 页面内生成浮窗广告
### 恶意脚本时怎么注入的
1. 存储型XSS攻击

（图片 存储型XSS）
- 首先黑客利用站点漏洞将一段恶意JS代码提交到网站的数据库
- 然后用户向网站请求包含了恶意JS脚本的页面
- 当用户浏览该页面，恶意脚本执行，会将用户的Cookie等信息数据上传到服务器
2. 反射型XSS攻击

恶意JavaScript脚本属于用户发送给网站请求的一部分，随后网站又把恶意JS脚本返回给用户，当恶意JS脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。现实生活中，黑客经常会通过QQ群或者邮件等渠道诱导用户点击恶意链接，web服务器不会存储反射型XSS攻击的恶意脚本
3. 基于DOM的XSS攻击

基于DOM的XSS攻击是不牵涉到页面web服务器的，具体讲，黑客利用各种手段讲恶意脚本注入用户页面，比如通过网络劫持在页面传输过程中修改HTML页面内容，这种劫持类型很多，比如通过WIFI路由器劫持，有通过本地恶意软件劫持，它们的共同点事在web资源传输过程或者在用户使用页面过程中修改web页面的数据。
4. 如何防止XSS攻击
- 服务器对输入脚本进行过滤或转码
- 充分利用CSP： 限制加载其他域下的资源文件，禁止向第三方域提交数据，这样用户数据也不会外泄，禁止直行内联脚本和未授权的脚本，提供上报机制。
- 使用HTTPOnly属性
## CSRF攻击
（图片：CSRF攻击）
黑客利用了用户的登录状态，通过第三方站点来做一些坏事
- 自动发起Get，Post请求
- 引诱用户电机连接： 通常在论坛或者恶意邮件
黑客站点代码，页面上放了一张图片，下面放了图片连接地址，而这个下载地址实际是黑客用来转账的接口，一旦用户点击了连接，那么他的币就被转到黑客账户。
和XSS不同的是，CSRF攻击不需要将恶意代码注入用户页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击
### 如何预防？
- 充分利用好Cookie的SameSite属性（Strict Lax 和None三个值）
1. Strict最严格，如果SameSite值是Strict，那么浏览器完全禁止第三方Cookie，简言之，如果你从极客时间的页面中访问InfoQ资源，而InfoQ的某些cookie设置了SameSite= Strict的话，那么这些Cookie是不会被发送到InfoQ服务器上的，只有你从INfoQ站点去请求InfoQ的资源，才会带上这些Coolie。
2. Lax相对宽松，在跨站情况下，从第三方站点的连接打开和从第三方站点提交Get方式表单这两种方式都会携带COokie，但如果在第三方站点中使用Post方法，或者通过img，iframe等标签加的URL，这些场景都不会携带Cookie
3. 而如果使用None，在任何时候都会发送Cookie数据
  - 验证请求来源站点：Referer是HTTP请求头中的一个字段，记录了该HTTP请求的来源地址，ORigin属性，在一些重要的场合，比如通过XMLHTTPRequest，Fetch发起跨站请求或者通过Post方法发送请求，都会带上ORigin属性。origin属性只包含域名信息，并没有包含具体URL路径，这是ORigin和Reeferer的一个主要区别。服务器策略是优先判断Origin，如果请求头中没有ORrgin属性，再根据实际情况判断是否使用Referer值。
  - CSRF Token： 在浏览器向服务器发起请求时，服务器生成一个CSRF Token。在浏览器端如果要发起转账请求，那么需要带上页面中的CSRF Token，然后服务器会验证该TOken合法性
  ## HTTPs
  HTTP一直保持着明文传输数据的特征，在传输过程的每一个环节数据都可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人，你们通信过程的每一个内容，都在中间人的掌握中·

  https：HTTP层和TCP
层做了安全机制（SSL/TLS）

对发起HTTP请求的数据进行加密操作和对接收的HTTP内容解密
- 对称加密是指加密解密使用相同的秘钥
- 非对称加密算法有A、B两把秘钥，A加密，只能用B解密，反之亦然。公钥是每个人都能获取到，而私钥只有服务器知道，不公开。
- 

### 添加数字证书